# Generated by nuclio.export.NuclioExporter

import warnings
from typing import Union

warnings.simplefilter(action="ignore", category=FutureWarning)

import mlrun.feature_store as fstore
import pandas as pd
import plotly.express as px
import plotly.figure_factory as ff
import plotly.graph_objects as go
from mlrun.artifacts import (
    DatasetArtifact,
    PlotlyArtifact,
    TableArtifact,
    update_dataset_meta,
)
from mlrun.datastore import DataItem
from mlrun.execution import MLClientCtx
from mlrun.feature_store import FeatureSet, FeatureVector
from plotly.subplots import make_subplots

pd.set_option("display.float_format", lambda x: "%.2f" % x)
MAX_SIZE_OF_DF = 5000 * 10


def analyze(
    context: MLClientCtx,
    name: str = "dataset",
    table: Union[FeatureSet, DataItem] = None,
    label_column: str = None,
    plots_dest: str = "plots",
    frac: float = 0.10,
) -> None:
    """
    The function will output the following artifacts per
    column within the data frame (based on data types):

    histogram matrix chart
    histogram per feature chart
    violin chart
    correlation-matrix chart
    correlation-matrix csv
    imbalance pie chart
    imbalance-weights-vec csv

    :param context:                 the function context
    :param name:                    key of dataset to database ("dataset" for default)
    :param table:                   MLRun input pointing to pandas dataframe (csv/parquet file path) or FeatureSet as param
    :param label_column:            ground truth column label
    :param plots_dest:              destination folder of summary plots (relative to artifact_path)
                                    ("plots" for default)
    :param frac:                    when the table has more than 5000 samples,
                                    the function will execute on random frac from the data (0.1 default)
    """
    data_item, featureset, creat, update = False, False, False, False
    if type(table) == DataItem:
        if table.meta is None:
            data_item, creat, update = True, True, False
        elif table.meta.kind == "dataset":
            data_item, creat, update = True, False, True
        elif table.meta.kind == "FeatureVector":
            data_item, creat, update = True, False, False
        elif table.meta.kind == "FeatureSet":
            featureset, creat, update = True, False, False

    if data_item:
        df = table.as_df()
    elif featureset:
        project_name, set_name = table._path.split("/")[2], table._path.split("/")[4]
        feature_set = fstore.get_feature_set(
            f"store://feature-sets/{project_name}/{set_name}"
        )
        df = feature_set.to_dataframe()
    else:
        context.logger.error(f"Wrong table type.")
        return

    if df.size > MAX_SIZE_OF_DF:
        df = df.sample(frac=frac)
    extra_data = {}

    if label_column not in df.columns:
        label_column = None

    extra_data["describe csv"] = context.log_artifact(
        TableArtifact("describe-csv", df=df.describe()),
        local_path=f"{plots_dest}/describe.csv",
    )

    try:
        _create_histogram_mat_artifact(
            context, df, extra_data, label_column, plots_dest
        )
    except Exception as e:
        context.logger.warn(f"Failed to create histogram matrix artifact due to: {e}")
    try:
        _create_features_histogram_artifacts(
            context, df, extra_data, label_column, plots_dest
        )
    except Exception as e:
        context.logger.warn(f"Failed to create pairplot histograms due to: {e}")
    try:
        _create_violin_artifact(context, df, extra_data, plots_dest)
    except Exception as e:
        context.logger.warn(f"Failed to create violin distribution plots due to: {e}")
    try:
        _create_imbalance_artifact(context, df, extra_data, label_column, plots_dest)
    except Exception as e:
        context.logger.warn(f"Failed to create class imbalance plot due to: {e}")
    try:
        _create_corr_artifact(context, df, extra_data, label_column, plots_dest)
    except Exception as e:
        context.logger.warn(f"Failed to create features correlation plot due to: {e}")

    if not data_item:
        return

    artifact = table.artifact_url
    if creat:  # dataset not stored
        artifact = DatasetArtifact(
            key="dataset", stats=True, df=df, extra_data=extra_data
        )
        artifact = context.log_artifact(artifact, db_key=name)
        context.logger.info(f"The data set is logged to the project under {name} name")

    if update:
        update_dataset_meta(artifact, extra_data=extra_data)
        context.logger.info(f"The data set named {name} is updated")

    # TODO : Plots according to client wishes - like preform histogram on selected features.
    # TODO : 3-D plot on on selected features.
    # TODO : Reintegration plot on on selected features.
    # TODO : PCA plot (with options)


def _create_histogram_mat_artifact(
    context: MLClientCtx,
    df: pd.DataFrame,
    extra_data: dict,
    label_column: str,
    plots_dest: str,
):
    """
    Create and log a histogram matrix artifact
    """

    fig = ff.create_scatterplotmatrix(df, diag="histogram", width=2500, height=2500)
    if label_column is not None:
        df_new = df.copy()
        df_new[label_column] = df_new[label_column].apply(str)
        fig = ff.create_scatterplotmatrix(
            df_new, diag="histogram", index=label_column, width=2500, height=2500
        )
    fig.update_layout(title_text="<i><b>Histograms matrix</b></i>")
    extra_data["histogram-matrix"] = context.log_artifact(
        PlotlyArtifact(key="histograms-matrix", figure=fig),
        local_path=f"{plots_dest}/hist_mat.html",
    )


def _create_features_histogram_artifacts(
    context: MLClientCtx,
    df: pd.DataFrame,
    extra_data: dict,
    label_column: str,
    plots_dest: str,
):
    """
    Create and log a histogram artifact for each feature
    """

    figs = dict()
    for (columnName, _) in df.iteritems():
        if columnName == label_column:
            continue
        sub_fig = go.Histogram(x=df[columnName])
        figs[columnName] = sub_fig

    fig = go.Figure()
    for k in figs.keys():
        fig.add_trace(figs[k])

    fig.update_traces(visible=False)
    all_buttons = [""] + list(figs.keys())
    fig.update_layout(
        updatemenus=[
            {
                "buttons": [
                    {
                        "label": column_name,
                        "method": "update",
                        "args": [
                            {"visible": [key == column_name for key in figs.keys()]},
                            {"title": f"<i><b>Histogram of {column_name}</b></i>"},
                        ],
                    }
                    for column_name in all_buttons
                ]
            }
        ],
    )

    fig.update_layout(
        width=800,
        height=600,
        autosize=False,
        margin=dict(t=100, b=0, l=0, r=0),
        template="plotly_white",
    )

    fig.update_layout(title_text=f"<i><b>Histograms</b></i>")
    extra_data[f"histograms"] = context.log_artifact(
        PlotlyArtifact(key=f"histograms", figure=fig),
        local_path=f"{plots_dest}/histograms.html",
    )


def _create_violin_artifact(
    context: MLClientCtx, df: pd.DataFrame, extra_data: dict, plots_dest: str
):
    """
    Create and log a violin artifact
    """
    cols = 4
    rows = (df.shape[1] // cols) + 1
    fig = make_subplots(rows=rows, cols=cols)

    plot_num = 0

    for (columnName, columnData) in df.iteritems():
        violin = go.Violin(
            x=[columnName] * columnData.shape[0],
            y=columnData,
            name=columnName,
        )

        fig.add_trace(
            violin,
            row=(plot_num // cols) + 1,
            col=(plot_num % cols) + 1,
        )

        plot_num += 1

    fig["layout"].update(
        height=(rows + 1) * 200,
        width=(cols + 1) * 200,
        title="<i><b>Violin Plots</b></i>",
    )
    extra_data["violin"] = context.log_artifact(
        PlotlyArtifact(key="violin", figure=fig),
        local_path=f"{plots_dest}/violin.html",
    )


def _create_imbalance_artifact(
    context: MLClientCtx,
    df: pd.DataFrame,
    extra_data: dict,
    label_column: str,
    plots_dest: str,
):
    """
    Create and log an imbalance class artifact (csv + plot)
    """
    if label_column:
        labels_count = df[label_column].value_counts().sort_index()
        df_labels_count = pd.DataFrame(labels_count)
        df_labels_count.rename(columns={label_column: "Total"}, inplace=True)
        df_labels_count[label_column] = labels_count.index

        fig = px.pie(df_labels_count, names=label_column, values="Total")
        fig.update_layout(title_text="<i><b>Labels balance</b></i>")
        extra_data["imbalance"] = context.log_artifact(
            PlotlyArtifact(key="imbalance", figure=fig),
            local_path=f"{plots_dest}/imbalance.html",
        )
        extra_data["imbalance-csv"] = context.log_artifact(
            TableArtifact(
                "imbalance-weights-vec", df=pd.DataFrame({"weights": labels_count})
            ),
            local_path=f"{plots_dest}/imbalance-weights-vec.csv",
        )


def _create_corr_artifact(
    context: MLClientCtx,
    df: pd.DataFrame,
    extra_data: dict,
    label_column: str,
    plots_dest: str,
):
    """
    Create and log an correlation-matrix artifact (csv + plot)
    """
    if label_column is not None:
        df = df.drop([label_column], axis=1)
    tblcorr = df.corr()
    extra_data["correlation-matrix-csv"] = context.log_artifact(
        TableArtifact("correlation-matrix-csv", df=tblcorr, visible=True),
        local_path=f"{plots_dest}/correlation-matrix.csv",
    )

    z = tblcorr.values.tolist()
    z_text = [["{:.2f}".format(y) for y in x] for x in z]
    fig = ff.create_annotated_heatmap(
        z,
        x=list(tblcorr.columns),
        y=list(tblcorr.columns),
        annotation_text=z_text,
        colorscale="agsunset",
    )
    fig["layout"]["yaxis"]["autorange"] = "reversed"  # l -> r
    fig.update_layout(title_text="<i><b>Correlation matrix</b></i>")
    fig["data"][0]["showscale"] = True

    extra_data["correlation"] = context.log_artifact(
        PlotlyArtifact(key="correlation", figure=fig),
        local_path=f"{plots_dest}/correlation.html",
    )
